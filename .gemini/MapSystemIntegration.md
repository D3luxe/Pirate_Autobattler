# Map System Integration with UI Toolkit MapPanel

This document outlines the steps required to integrate the newly refactored map generation system with the `UIToolkit MapPanel`.

## Phase 1: Map Generation and Data Provisioning

1.  **Trigger Map Generation:**
    *   Identify the appropriate game state or event to trigger the `MapGenerator.GenerateMap()` method (e.g., `GameSession.StartNewRun()`, `ActManager.StartNewAct()`).
    *   Pass in the necessary `ActSpec`, `Rules`, and `seed`.

2.  **Store Generated Map:**
    *   The `MapManager` should hold the generated `MapGraph` instance.
    *   Add a property or method to `MapManager` to store and retrieve the `MapGraph`.

3.  **Transform `MapGraph` to `MapNodeData`:**
    *   Create a new component or extend `MapManager` to convert the `MapGraph` into the `List<List<MapNodeData>>` format expected by `MapPanel`.
    *   This conversion should:
        *   Iterate through the `MapGraph.Nodes` and `MapGraph.Edges`.
        *   For each `Node`, create a `MapNodeData` object.
        *   Populate `MapNodeData.encounter` (type and id) from `Node.Type`.
        *   **Attach UI Metadata:** Implement logic to determine `iconPath` and `tooltipText` for each `MapNodeData` based on its `NodeType` and any other relevant game data (e.g., `ScriptableObject`s for encounters). This might involve a lookup service.
        *   Populate `MapNodeData.nextNodeIndices` by mapping `Edge.ToId` to the column-based index expected by `MapPanel`.
        *   **Precompute Reachability Cache:** Determine which nodes are reachable from the player's current position. This information will be crucial for enabling/disabling UI elements. Store this in `MapNodeData` or a separate lookup.

4.  **Update `MapManager.GetMapNodes()`:**
    *   Modify `MapManager.GetMapNodes()` to return the transformed `List<List<MapNodeData>>`.

## Phase 2: UI Display and Interaction

1.  **Update `MapPanel` to use `MapManager`:**
    *   Ensure `MapPanel.GenerateMapVisuals()` correctly retrieves the `List<List<MapNodeData>>` from `MapManager`.
    *   Verify that node positioning, icon display, and tooltip handling work as expected with the new data.

2.  **Implement Player Position and Reachability Highlighting:**
    *   `MapPanel` needs to visually indicate the player's current node.
    *   Nodes that are not reachable from the player's current node should be visually disabled or greyed out.
    *   Update this visual state whenever the player moves to a new node.

3.  **Integrate Node Click Logic:**
    *   Refine `MapPanel.OnNodeClicked()` to:
        *   Validate if the clicked node is reachable.
        *   If an "Unknown" node is clicked, trigger the `Unknowns.ResolveUnknown()` method.
        *   Update the `GameSession.CurrentRunState` with the new `currentColumnIndex` and `currentEncounterId`.
        *   Handle scene loading based on the resolved `EncounterType`.

## Phase 3: Pity State and Deterministic Replays

1.  **Pity State Management:**
    *   Initialize `PityState` at the start of a new run (e.g., in `GameSession`).
    *   Pass the `PityState` to `Unknowns.ResolveUnknown()` when an unknown node is resolved.
    *   Persist the `PityState` as part of the game save data.

2.  **Deterministic Replays:**
    *   Ensure that the `seed` and `sub-seeds` generated by `MapGenerator` are saved as part of the run data.
    *   Implement a mechanism to load a run from a saved seed, allowing the map to be regenerated deterministically.

## Phase 4: Refinement and Testing

1.  **Error Handling and Edge Cases:**
    *   Add robust error handling for scenarios like no valid paths, missing data, etc.
    *   Test various map configurations and act specifications.

2.  **Performance Optimization:**
    *   Consider performance for very large maps, especially during the `MapGraph` to `MapNodeData` conversion and reachability calculations.

3.  **Unit and Integration Tests:**
    *   Write tests for the `MapGraph` to `MapNodeData` conversion logic.
    *   Write integration tests to ensure the `MapGenerator`, `MapManager`, and `MapPanel` work together seamlessly.
