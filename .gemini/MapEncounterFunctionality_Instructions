## Map Encounter Interaction Analysis and Implementation Plan

### 1. Analysis of Current Logic

The current map interaction logic is primarily handled within `MapView.cs`.

*   **Node Interaction:** When a player clicks a node on the map, the `OnNodeClicked` method is invoked.
    *   **File:** `Assets/Scripts/UI/MapView.cs:610-653`
    ```csharp
    private void OnNodeClicked(string nodeId)
    {
        // ... (validation logic) ...

        Debug.Log($"Valid move! Moving from {currentPlayerNode.id} to {clickedNode.id}.");
        GameSession.CurrentRunState.currentEncounterId = clickedNode.id;
        GameSession.CurrentRunState.currentColumnIndex = clickedNode.row;

        GameSession.InvokeOnPlayerNodeChanged();
    }
    ```
*   **State Update:** The `OnNodeClicked` method validates the move. If valid, it updates the `GameSession.CurrentRunState` with the new `currentEncounterId` and `currentColumnIndex`.
*   **Event Invocation:** After updating the state, it calls `GameSession.InvokeOnPlayerNodeChanged()`.
    *   **File:** `Assets/Scripts/Core/GameSession.cs:20-23`
    ```csharp
    public static event Action OnPlayerNodeChanged; // New event

    public static void InvokeOnPlayerNodeChanged()
    {
        OnPlayerNodeChanged?.Invoke();
    }
    ```
*   **Missing Link:** The critical missing piece is a subscriber to the `GameSession.OnPlayerNodeChanged` event. The game state is updated to reflect the player's new position, but no system is listening for this change to initiate the actual encounter (e.g., loading a battle, opening a shop). The `RunManager`, which is responsible for managing the game flow, does not currently subscribe to this event.
    *   **File:** `Assets/Scripts/Core/RunManager.cs`
    *   **Evidence:** A search for `OnPlayerNodeChanged` in `RunManager.cs` shows no subscriptions.

### 2. Implementation Plan

To connect the map node click to the corresponding encounter, the `RunManager` must listen for the node change event and act accordingly.

1.  **Subscribe `RunManager` to `OnPlayerNodeChanged`:**
    *   **File:** `Assets/Scripts/Core/RunManager.cs`
    *   **Action:** In the `Awake()` method, add a subscription to the `GameSession.OnPlayerNodeChanged` event.
    *   **Code (to be added in `Awake`)**:
        ```csharp
        GameSession.OnPlayerNodeChanged += HandlePlayerNodeChanged;
        ```
    *   **Action:** In the `OnDestroy()` method, add the corresponding unsubscription.
    *   **Code (to be added in `OnDestroy`)**:
        ```csharp
        GameSession.OnPlayerNodeChanged -= HandlePlayerNodeChanged;
        ```

2.  **Implement the Event Handler in `RunManager`:**
    *   **File:** `Assets/Scripts/Core/RunManager.cs`
    *   **Action:** Create a new private method `HandlePlayerNodeChanged` to process the event.
    *   **Logic:**
        1.  Check if `GameSession.CurrentRunState` and its `currentEncounterId` are valid.
        2.  Retrieve the `MapGraphData.Node` from `MapManager.Instance.GetMapGraphData().nodes` that corresponds to the `currentEncounterId`.
        3.  Parse the `node.type` string into the `PirateRoguelike.Data.EncounterType` enum.
        4.  Use a `switch` statement on the encounter type to determine the action.
        5.  For `EncounterType.Battle`, load the "Battle" scene using `SceneManager.LoadScene("Battle")`.
        6.  For other types (`Shop`, `Treasure`, etc.), add `Debug.Log` placeholders for now.

    *   **Proposed Code:**
        ```csharp
        private void HandlePlayerNodeChanged()
        {
            if (GameSession.CurrentRunState == null || string.IsNullOrEmpty(GameSession.CurrentRunState.currentEncounterId))
            {
                Debug.LogWarning("HandlePlayerNodeChanged called with invalid GameSession state.");
                return;
            }

            var mapData = MapManager.Instance.GetMapGraphData();
            if (mapData == null)
            {
                Debug.LogError("MapGraphData is null. Cannot handle node change.");
                return;
            }

            var currentNode = mapData.nodes.Find(n => n.id == GameSession.CurrentRunState.currentEncounterId);
            if (currentNode == null)
            {
                Debug.LogError($"Could not find node with ID: {GameSession.CurrentRunState.currentEncounterId}");
                return;
            }

            if (System.Enum.TryParse<PirateRoguelike.Data.EncounterType>(currentNode.type, true, out var encounterType))
            {
                Debug.Log($"Player moved to node {currentNode.id} of type {encounterType}.");

                switch (encounterType)
                {
                    case PirateRoguelike.Data.EncounterType.Battle:
                        // Before loading, hide the map to prevent it from overlapping the next scene
                        if (_mapView != null) _mapView.Hide();
                        SceneManager.LoadScene("Battle");
                        break;
                    case PirateRoguelike.Data.EncounterType.Shop:
                        if (_mapView != null) _mapView.Hide();
                        SceneManager.LoadScene("Shop");
                        break;
                    case PirateRoguelike.Data.EncounterType.Treasure:
                        Debug.Log("Treasure encounter triggered. Implementation pending.");
                        // Future: Grant rewards directly or show a simple reward UI
                        break;
                    case PirateRoguelike.Data.EncounterType.Boss:
                         if (_mapView != null) _mapView.Hide();
                        SceneManager.LoadScene("Battle"); // Assuming boss fights use the same scene
                        break;
                    default:
                        Debug.LogWarning($"Unhandled encounter type: {encounterType}");
                        break;
                }
            }
            else
            {
                Debug.LogError($"Failed to parse encounter type: {currentNode.type}");
            }
        }
        ```

This plan establishes the missing connection between the UI action (`OnNodeClicked`) and the game logic (`RunManager`), enabling encounters to be triggered correctly.

### 3. Encounter-Specific Analysis (Revised)

The project defines a set of encounter types and uses `ScriptableObject` assets (`EncounterSO`) to hold their data.

*   **Encounter Types Defined:**
    *   **File:** `Assets/Scripts/Data/DataTypes.cs:15`
    ```csharp
    public enum EncounterType { Battle, Shop, Port, Event, Treasure, Boss }
    ```

*   **Existing `EncounterSO` Assets:**
    *   **Path:** `Assets/Resources/GameData/Encounters/`
    *   **Files:** `enc_battle.asset`, `enc_boss.asset`, `enc_port.asset`, `enc_shop.asset`, `event_ghost_ship.asset`
    *   This corresponds to the `Battle`, `Boss`, `Port`, `Shop`, and `Event` encounter types.

*   **Existing Scenes:**
    *   **Path:** `Assets/Scenes/`
    *   **Build Scenes:** `MainMenu`, `Boot`, `Run`, `Battle`, `Summary`. There is no `Shop.unity` scene. The `ShopManager.cs` script's `LeaveShop()` method loads the `Run` scene, implying the shop is likely intended to be its own scene.

*   **Encounter Status:**

| Encounter Type | `EncounterSO` Exists? | Backend Logic | Scene/UI Exists? | Status | Next Steps |
| :--- | :--- | :--- | :--- | :--- | :--- |
| **Battle** | Yes (`enc_battle.asset`) | Yes (`BattleManager.cs`) | Yes (`Battle.unity`) | **Functional** | Connect via `RunManager` event handler. |
| **Boss** | Yes (`enc_boss.asset`) | Yes (`BattleManager.cs`) | Yes (`Battle.unity`) | **Functional** | Connect via `RunManager` event handler. |
| **Shop** | Yes (`enc_shop.asset`) | Yes (`ShopManager.cs`) | Partial (`ShopUI.cs`) | **Partially Implemented** | 1. Create a new `Shop.unity` scene. 2. Add the `ShopManager` and a `UIDocument` to the scene. 3. Refactor `ShopUI.cs` and its associated prefabs (`ShopItemViewPrefab`, `ShopShipViewPrefab`) to use UI Toolkit instead of `UnityEngine.UI`. 4. Create a `Shop.uxml` document for the layout. |
| **Port** | Yes (`enc_port.asset`) | No | No | **Pending** | Define functionality. Likely a variation of a shop or event. |
| **Event** | Yes (`event_ghost_ship.asset`) | No | No | **Pending** | Create a generic `EventManager.cs` and `EventView` UI panel to display event text and choices. |
| **Treasure** | No | No | No | **Pending** | No data asset needed. Implement logic in `RunManager` to directly grant rewards, potentially with a simple UI popup. |
